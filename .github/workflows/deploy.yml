name: Build, Push, and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      rollback:
        description: 'Rollback to previous version'
        type: boolean
        default: false
      version:
        description: 'Version to rollback to (if empty, rolls back to previous version)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  APP_PORT: 5005
  DATABASE_URL: postgres://${{ secrets.PGUSER }}:${{ secrets.PGPASSWORD }}@${{ secrets.PGHOST }}:${{ secrets.PGPORT }}/${{ secrets.PGDATABASE }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    if: ${{ !github.event.inputs.rollback }}
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.image-tag.outputs.image_tag }}
      deploy_id: ${{ steps.image-tag.outputs.deploy_id }}
      commit_url: ${{ steps.image-tag.outputs.commit_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set npm registry to public
        run: npm config set registry https://registry.npmjs.org/

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=short
            type=ref,event=branch
            latest
            type=raw,value=v1.0.{{date 'YYYYMMDD'}}.{{sha}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Output image tag
        id: image-tag
        run: |
          MAIN_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n1)
          echo "image_tag=$MAIN_TAG" >> $GITHUB_OUTPUT
          echo "deploy_id=$(date +%Y%m%d%H%M%S)-${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "commit_url=${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}" >> $GITHUB_OUTPUT

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: ${{ !github.event.inputs.rollback }}
    outputs:
      deploy_status: ${{ steps.deploy_result.outputs.status }}
      deploy_message: ${{ steps.deploy_result.outputs.message }}

    steps:
      - name: Get image tag
        run: |
          IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}
          DEPLOY_ID=${{ needs.build-and-push.outputs.deploy_id }}
          COMMIT_URL=${{ needs.build-and-push.outputs.commit_url }}
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "deploy_id=$DEPLOY_ID" >> $GITHUB_OUTPUT
          echo "commit_url=$COMMIT_URL" >> $GITHUB_OUTPUT

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to VPS
        id: deploy_result
        run: |
          DEPLOY_STATUS="success"
          DEPLOY_MESSAGE="Deployment successful"

          ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} <<EOF
            set -e
            cd ${{ secrets.SSH_PROJECT_PATH }}

            # Create .env file if needed
            touch .env

            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull the new image
            echo "Pulling image: ${{ needs.build-and-push.outputs.image_tag }}"
            docker pull ${{ needs.build-and-push.outputs.image_tag }}

            # Остановить и удалить старый контейнер, если он есть
            if docker ps -a --format '{{.Names}}' | grep -Eq '^skillchecker$'; then
              echo "Stopping and removing existing skillchecker container..."
              docker stop skillchecker || true
              docker rm skillchecker || true
            fi

            # Запустить новый контейнер
            echo "Starting new skillchecker container..."
            docker run -d --name skillchecker \
              --restart unless-stopped \
              -p 5005:5005 \
              -e NODE_ENV=production \
              -e DATABASE_URL=${{ env.DATABASE_URL }} \
              ${{ needs.build-and-push.outputs.image_tag }}

            # Проверить запуск
            ATTEMPTS=5
            for i in $(seq 1 $ATTEMPTS); do
              if curl --silent --fail http://localhost:5005 > /dev/null; then
                echo "Service is running!"
                break
              else
                echo "Attempt $i: Service not ready yet, waiting..."
                sleep 10
              fi
            done
            # Если сервис не запустился, вывести логи контейнера
            if ! curl --silent --fail http://localhost:5005; then
              echo "Service failed to start! Showing container logs:"
              docker logs $(docker ps -a -q --filter ancestor=ghcr.io/brrovko/skillchecker.tech:main --format="{{.ID}}") || true
              exit 1
            fi

            # Clean up old images (keep last 3)
            docker image prune -a -f --filter "until=72h"
          EOF

          if [ $? -ne 0 ]; then
            DEPLOY_STATUS="failure"
            DEPLOY_MESSAGE="Deployment failed"
          fi

          echo "status=$DEPLOY_STATUS" >> $GITHUB_OUTPUT
          echo "message=$DEPLOY_MESSAGE" >> $GITHUB_OUTPUT

      - name: Send deployment notification
        if: always()
        run: |
          DEPLOY_STATUS="${{ steps.deploy_result.outputs.status }}"
          DEPLOY_MESSAGE="${{ steps.deploy_result.outputs.message }}"
          COMMIT_URL="${{ steps.image-tag.outputs.commit_url }}"

          if [ "$DEPLOY_STATUS" == "success" ]; then
            STATUS_EMOJI="✅"
          else
            STATUS_EMOJI="❌"
          fi

          echo "::notice::$STATUS_EMOJI Deployment $DEPLOY_STATUS: $DEPLOY_MESSAGE (Commit: $COMMIT_URL)"

  rollback:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.rollback }}
    outputs:
      rollback_status: ${{ steps.rollback_result.outputs.status }}
      rollback_message: ${{ steps.rollback_result.outputs.message }}

    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Rollback to previous version
        id: rollback_result
        run: |
          ROLLBACK_STATUS="success"
          ROLLBACK_MESSAGE="Rollback successful"

          if [ -z "${{ github.event.inputs.version }}" ]; then
            echo "Error: Version for rollback not provided!" >&2
            ROLLBACK_STATUS="failure"
            ROLLBACK_MESSAGE="Rollback failed: version not provided."
            echo "status=$ROLLBACK_STATUS" >> $GITHUB_OUTPUT
            echo "message=$ROLLBACK_MESSAGE" >> $GITHUB_OUTPUT
            exit 1
          fi

          ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} <<'EOF'
            set -e
            cd ${{ secrets.SSH_PROJECT_PATH }}

            ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.version }}"
            echo "Rolling back to specific version: $ROLLBACK_IMAGE"

            if docker ps -a --format '{{.Names}}' | grep -Eq '^skillchecker$'; then
              docker stop skillchecker || true
              docker rm skillchecker || true
            fi

            echo "Starting skillchecker container with rollback image..."
            docker run -d --name skillchecker \
              --restart unless-stopped \
              -p 5005:5005 \
              -e NODE_ENV=production \
              -e DATABASE_URL=${{ env.DATABASE_URL }} \
              $ROLLBACK_IMAGE

            # Проверить запуск
            for i in {1..6}; do
              if curl --silent --fail http://localhost:5005 > /dev/null; then
                echo "Rollback successful, service is running!"
                break
              else
                if [ $i -eq 6 ]; then
                  echo "Service failed to start after rollback!"
                  exit 1
                else
                  echo "Attempt $i: Service not ready yet, waiting..."
                  sleep 10
                fi
              fi
            done

            echo "Rolled back successfully"
          EOF

          echo "status=$ROLLBACK_STATUS" >> $GITHUB_OUTPUT
          echo "message=$ROLLBACK_MESSAGE" >> $GITHUB_OUTPUT

      - name: Send rollback notification
        if: always()
        run: |
          ROLLBACK_STATUS="${{ steps.rollback_result.outputs.status }}"
          ROLLBACK_MESSAGE="${{ steps.rollback_result.outputs.message }}"

          if [ "$ROLLBACK_STATUS" == "success" ]; then
            STATUS_EMOJI="✅"
          else
            STATUS_EMOJI="❌"
          fi

          echo "::notice::$STATUS_EMOJI Rollback $ROLLBACK_STATUS: $ROLLBACK_MESSAGE"
